PARSER_BEGIN( Frontend )
  package frontend;

import java.util.Map;
import java.util.TreeMap;
import java.util.HashMap;
import java.util.Stack;

public class Frontend {
  String party_one_name;
  String party_two_name;
  String prog_name;
    
  ProgramTree tree;
  int line_num;

  Map<String, Variable> scope;
  
  public ProgramTree read(){
    boolean errors = false;
    tree = new ProgramTree();
    scope = new HashMap<String,Variable>();
    line_num = 0;
    try {
      file();
    } catch ( CompileException e ){
      log( e );
      errors = true;
    }
    if( errors ){
      return null; // fix this
    }
  }
  
  private int resolve_party( String party ) throws CompileException {
    if( party.equals( party_one_name ) ){
      return 1;
    } else if( party.equals( party_two_name ) ){
      return 2;
    } else {
      throw error( "Cannot resolve party: "+party );
    }
    
    return 0;
  }

  private void log( Exception e ){
    System.out.println( e.getMessage() );
  }

  private Variable getVar( String name ){
    return scope.get( name );
  }

  private void checkVarName( String name ) throws CompileException {
    Variable alread_defined = getVar( name );
    if( alread_defined != null ){
      throw error( "Variable \""+name+"\" already defined" );
    }
  }
  
  private void defineVariable( String name, Variable v ){
    scope.put( name, v );
  }

  private CompileException error( String mess ){
    return new CompileException( mess, linenum );
  }
}

PARSER_END( Frontend )

SKIP: {" " | "\t" | "\r"}

TOKEN: {
  < NEW_LINE : "\n" > |             
    < OPEN_BRACKET : "[" > |
    < CLOSE_BRACKET : "]" > |
    < OPEN_PAREN : "(" > |
    < CLOSE_PAREN : ")" > |
    < OPEN_CURLY : "{" > |
    < CLOSE_CURLY : "}" > |
    < OPEN_ANGLE : "<" > |
    < CLOSE_ANGLE : ">" > |
    < COMMA : "," > |
    < EQUAL : "=" > |
    < SEMICOLON : ";" > |
    < COLON : ":" > |
    < TO : "to" > |
    < IF : "if" > |
    < FOR : "for" > |
    < FROM : "from" > |
    < RETURN : "return" > |
    < PROGRAM : "program" > |
    < INTEGER : ("-")? (["0"-"9"])+ > |
    < IDENTIFIER : ["a"-"z"] ( ["a"-"z"] | ["0"-"9"] )* >
    }

void file() throws CompileException:
{
}
{
  ProgramStart()
  <OPEN_CURLY>
    ProgramBody()
  <CLOSE_CURLY>
  <EOF>
}

void ProgramStart():
{
  // only supports two parties now
}
{
  <PROGRAM>
  <OPEN_BRACKET>
    party_one_name = Identifier()
    <COMMA>
    party_two_name = Identifier()
  <CLOSE_BRACKET>
    prog_name = Identifier()
}

void InputDeclaration() throws CompileException:
{
  Type type;
  int party_num;
  String var_name;
}
{
  party_num = PartyName()
    <COLON>
  type = TypeDeclaration()
    var_name = Identifier()  

  {
    checkVarName( var_name );
    Variable in = new Variable( type );
    defineVariable( var_name, in );
    tree.addInputVariable( party_num, in );
  }
  <SEMICOLON>
}

Type TypeDeclaration() throws CompileException:
{
  String typename;
  Type type;
  boolean is_array;
  int array_size;
}
{
  typename = Identifier()
    (
     <OPEN_BRACKET>
     array_size = IntDigits()
       {
	 is_array = true;
       }
     <CLOSE_BRACKET>
     )?
  {
    type = Type.from_name( typename );
    if( type == null ){
      throw error( "Type \""+typename+"\" not found" );
    }
    if( is_array ){
      if( array_size <= 0 ){
	throw error( "Arrays must have positive size" );
      }
      return new ArrayType( array_size, type );
    }
    return type;
  }
}

void Statement() throws CompileException:
{
  Statement s;
}
{
  ( 
   s = ForLoop() |
   s = Expression() |
   s = Return() |
   s = VariableCreation()
    )
    <SEMICOLON>
    {
      tree.addStatement(s);
    }
}

Statement ForLoop() throws CompileException:
{
  
}
{
  
}

Expression Return() throws CompileException:
{
  Expression ex;
}
{
  <RETURN>
    ex = Expression()
  {
    return ex;
  }
}

Statement VariableCreation() throws CompileException:
{
  
}
{
  
}

Expression Expression() throws CompileException:
{
  
}
{
  
}

Variable Constant() throws CompileException:
{
  
}
{
  
}

int PartyName() throws CompileException:
{ Token t; }
{
  t = <IDENTIFIER>
  { return resolve_party( t.image; ) }
}

void ProgramBody() throws CompileException:
{
}
{
  ( InputDeclaration() )*
    ( Statement()
      <SEMICOLON> )*
}

String Identifier():
{ Token t; }
{
  t = <IDENTIFIER>
  { return t.image; }
}

int IntDigits():
{ Token t; }
{
  t = <INTEGER>
  { 
    try{
      return Integer.parseInt( t.image );
    } catch( NumberFormatException e ){
      // will never happen
      return 0;
    }
  }
}

/*
Map<String,Type> ArgumentList() throws CompileException:
{
  Map<String,Type> args = new TreeMap<String,Type>();
  String cur_arg;
  Type cur_type;
}
{
  <OPEN_PAREN>
  (
   cur_type = TypeDeclaration()
   cur_arg = Identifier()
   {
     args.put( cur_arg, cur_type );
   }
   ( <COMMA> )?
   )*
  <CLOSE_PAREN>
    {
      return args;
    }
}
*//*
void FunctionDeclaration() throws CompileException:
{
  Type out_type;
  String func_name;
  Map<String, Type> args;
}
{
  out_type = TypeDeclaration()
    func_name = Identifier()
    args = ArgumentList()

  <OPEN_CURLY>
     ( Statement()
       <SEMICOLON> )*
  <CLOSE_CURLY>
  {
    leave_local_scope();
  }
}
*/
